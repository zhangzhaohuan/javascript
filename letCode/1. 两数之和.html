<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /* 题干:
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
**/

      // -----------------------------------------------------

      /****
       * !important
       * !题型:两数之和|差|积|商等等
       * 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗
       * 方法二： 时间复杂度 o(n)
       *
       * 分析：如何判断一个数组中任意两个数的和？
       * 第2个与前1个数、第3个与前两个数、......第n-1个与前n-2个数、第n个与前n-1个数比较即可
       *
       * 方便理解，将顺序倒一下，如下
       *        ||
       *        ||
       * （第n个与前n-1个数、第n-1个与前n-2个数......第3个与前两个数、第2个与前1个数 ）
       *
       *  那么用对象保存，然后比较非常方便
       *
       * **/

      var twoSum2 = function (nums, target) {
        const length = nums.length;
        if (length < 2) return false;
        const obj = {};
        for (let index = 0; index < nums.length; index++) {
          const element = nums[index];
          const diff = target - element;
          if (obj[diff] !== undefined) {
            return [obj[diff], index];
          }
          obj[element] = index;
        }
        return false;
      };
      twoSum2([3, 2, 4], 6);

      // 方法一、时间复杂度 O(n2)
      var twoSum = function (nums, target) {
        const length = nums.length;
        for (let index = 0; index < length; index++) {
          const first = nums[index];
          for (let j = index + 1; j < length; j++) {
            const second = nums[j];
            if (first + second === target) {
              return [index, j];
            }
          }
        }
        return false;
      };
      twoSum([3, 2, 4], 6);
      // twoSum([2,7,11,15],9)
      // twoSum([3,3],6)
    </script>
  </body>
</html>
